#include "interpret.h"

#include "fatal_error.h"

// INTERPRETER VALUES //

#define RHINO_VALUE_KIND(MACRO) \
    MACRO(INVALID_RHINO_KIND)   \
                                \
    MACRO(RHINO_NONE)           \
    MACRO(RHINO_BOOL)           \
    MACRO(RHINO_INT)            \
    MACRO(RHINO_NUM)            \
    MACRO(RHINO_STR)

DECLARE_ENUM(RHINO_VALUE_KIND, RhinoValueKind, rhino_value_kind)
DEFINE_ENUM(RHINO_VALUE_KIND, RhinoValueKind, rhino_value_kind)

typedef struct
{
    RhinoValueKind kind;
    union
    {
        bool as_bool;
        int as_int;
        double as_num;
        char *as_str;
        void *as_ptr;
    };
} RhinoValue;

#define NONE_VALUE() ((RhinoValue){.kind = RHINO_NONE, .as_bool = false})
#define BOOL_VALUE(value) ((RhinoValue){.kind = RHINO_BOOL, .as_bool = value})
#define INT_VALUE(value) ((RhinoValue){.kind = RHINO_INT, .as_int = value})
#define NUM_VALUE(value) ((RhinoValue){.kind = RHINO_NUM, .as_num = value})
#define STR_VALUE(value) ((RhinoValue){.kind = RHINO_STR, .as_str = value})

// IO //

char float_to_str_buffer[64];

// FIXME: This implementation cannot handle particularly large floats
//        e.g. 1000000000000000000000000000000.1
void float_to_str(double x)
{
    size_t c = 0;

    if (x < 0)
    {
        float_to_str_buffer[c++] = '-';
        x = -x;
    }

    long long integer_portion = x;
    float rational_portion = x - integer_portion;

    int f = c;
    do
        float_to_str_buffer[c++] = '0' + integer_portion % 10;
    while (integer_portion /= 10);
    int l = c - 1;

    while (l > f)
    {
        char t = float_to_str_buffer[f];
        float_to_str_buffer[f++] = float_to_str_buffer[l];
        float_to_str_buffer[l--] = t;
    }

    if (rational_portion > 0.0001)
    {
        float_to_str_buffer[c++] = '.';
        while (rational_portion > 0.0001)
        {
            int d = rational_portion * 10;
            float_to_str_buffer[c++] = '0' + (d % 10);
            rational_portion = rational_portion * 10 - d;
        }
    }

    float_to_str_buffer[c] = '\0';
}

void output_to(RunOnString *output, const char *format, ...)
{
    if (!output)
    {
        va_list args;
        va_start(args, format);
        vprintf(format, args);
        va_end(args);
        return;
    }

    // FIXME: This could overflow
    char buffer[1024];

    va_list args;
    va_start(args, format);
    vsprintf(buffer, format, args);
    va_end(args);

    append_run_on_string_with_terminator(output, buffer);
}

// RECORDS //

typedef struct
{
    RhinoValue register_value[256];
} Record;

inline RhinoValue get_value(Record *record, vm_reg reg, uint8_t up)
{
    assert(up == 0); // TODO: Implement getting values that are upwards in the stack
    return record->register_value[reg];
}

inline RhinoValue *point_to_value(Record *record, vm_reg reg, uint8_t up)
{
    assert(up == 0); // TODO: Implement getting values that are upwards in the stack
    return record->register_value + reg;
}

inline void set_value(Record *record, vm_reg reg, uint8_t up, RhinoValue value)
{
    assert(up == 0); // TODO: Implement setting values that are upwards in the stack
    record->register_value[reg] = value;
}

// INTERPRET //

// TODO: Have functions of these be generated by build.py

#define FETCH_DATA(T, var)                                          \
    T var;                                                          \
    {                                                               \
        union                                                       \
        {                                                           \
            T data;                                                 \
            uint32_t word[wordsizeof(T)];                           \
        } as;                                                       \
        for (size_t i = 0; i < wordsizeof(T); i++)                  \
            as.word[i] = unit->instruction[program_counter++].word; \
        var = as.data;                                              \
    }

void interpret_unit(Unit *unit, RunOnString *output_string)
{
    size_t program_counter = 0;

    RhinoValue stack_value[128];
    size_t stack_pointer = 0;

    Record record;
    Record *r = &record;

    while (program_counter < unit->count)
    {
        // printf_instruction(unit, program_counter);
        Instruction ins = unit->instruction[program_counter++];

        switch (ins.op)
        {

        case OP_CALL:
        {
            FETCH_DATA(Unit *, data);
            interpret_unit(data, output_string);
            break;
        }

        case OP_JUMP:
            program_counter = ins.y;
            break;

        case OP_JUMP_IF:
        {
            RhinoValue value = get_value(r, ins.x, 0);
            if (value.kind != RHINO_BOOL)
                fatal_error("Could not interpret JUMP_IF_FALSE as value in register is %s.", rhino_value_kind_string(value.kind));

            if (value.as_bool == false)
                program_counter = ins.y;

            break;
        }

        case OP_COPY:
            set_value(r, ins.a, ins.x, get_value(r, ins.b, ins.x));
            break;

        case OP_COPY_UP:
            set_value(r, ins.a, ins.x, get_value(r, ins.b, 0));
            break;

        case OP_COPY_DN:
            set_value(r, ins.a, 0, get_value(r, ins.b, ins.x));
            break;

        case OP_LOAD_NONE:
            set_value(r, ins.a, ins.x, NONE_VALUE());
            break;

        case OP_LOAD_TRUE:
            set_value(r, ins.a, ins.x, BOOL_VALUE(true));
            break;

        case OP_LOAD_FALSE:
            set_value(r, ins.a, ins.x, BOOL_VALUE(false));
            break;

        case OP_LOAD_INT:
        {
            FETCH_DATA(int, data);
            set_value(r, ins.a, ins.x, INT_VALUE(data));
            break;
        }

        case OP_LOAD_NUM:
        {
            FETCH_DATA(double, data);
            set_value(r, ins.a, ins.x, NUM_VALUE(data));
            break;
        }

        case OP_LOAD_STR:
        {
            FETCH_DATA(char *, data);
            set_value(r, ins.a, ins.x, STR_VALUE(data));
            break;
        }

        case OP_OUT:
        {
            RhinoValue value = get_value(r, ins.a, ins.x);
            if (value.kind == RHINO_NONE)
                output_to(output_string, "none\n");
            else if (value.kind == RHINO_BOOL)
                output_to(output_string, "%s\n", value.as_bool ? "true" : "false");
            else if (value.kind == RHINO_INT)
                output_to(output_string, "%d\n", value.as_int);
            else if (value.kind == RHINO_NUM)
            {
                float_to_str(value.as_num);
                output_to(output_string, "%s\n", float_to_str_buffer);
            }
            else if (value.kind == RHINO_STR)
                output_to(output_string, "%s\n", value.as_str);
            else
                fatal_error("Could not output %s value.", rhino_value_kind_string(value.kind));

            break;
        }

        case OP_INC:
        case OP_DEC:
        {
            int diff = ins.op == OP_INC ? 1 : -1;
            RhinoValue *value = point_to_value(r, ins.a, ins.x);

            if (value->kind == RHINO_INT)
                value->as_int += diff;
            else if (value->kind == RHINO_NUM)
                value->as_num -= diff;
            else
                fatal_error("Could not interpret %s as value register (%d, %d) is %s.", op_code_string((OpCode)ins.op), ins.a, ins.x, rhino_value_kind_string(value->kind));

            break;
        }

        case OP_NEG:
        {
            RhinoValue value = get_value(r, ins.b, ins.x);

            if (value.kind == RHINO_INT)
                value.as_int = -value.as_int;
            else if (value.kind == RHINO_NUM)
                value.as_num = -value.as_num;
            else
                fatal_error("Could not interpret OP_NEG as value in register is %s.", rhino_value_kind_string(value.kind));

            set_value(r, ins.a, 0, value);
            break;
        }

        case OP_NOT:
        {
            RhinoValue value = get_value(r, ins.b, ins.x);

            if (value.kind == RHINO_BOOL)
                value.as_bool = !value.as_bool;
            else
                fatal_error("Could not interpret OP_NOT as value in register is %s.", rhino_value_kind_string(value.kind));

            set_value(r, ins.a, 0, value);
            break;
        }

#define CASE_BINARY_ARITHMETIC(OP, operation)                            \
    case OP:                                                             \
    {                                                                    \
        RhinoValue lhs = get_value(r, ins.a, 0);                         \
        RhinoValue rhs = get_value(r, ins.b, 0);                         \
        RhinoValue result = {.kind = RHINO_NUM};                         \
                                                                         \
        if (lhs.kind == RHINO_INT && rhs.kind == RHINO_INT)              \
        {                                                                \
            result.kind = RHINO_INT;                                     \
            result.as_int = lhs.as_int operation rhs.as_int;             \
        }                                                                \
                                                                         \
        else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_INT)         \
            result.as_num = lhs.as_num operation rhs.as_int;             \
                                                                         \
        else if (lhs.kind == RHINO_INT && rhs.kind == RHINO_NUM)         \
            result.as_num = lhs.as_int operation rhs.as_num;             \
                                                                         \
        else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_NUM)         \
            result.as_num = lhs.as_num operation rhs.as_num;             \
                                                                         \
        else                                                             \
            fatal_error(                                                 \
                "Could not interpret " #OP " between %s and %s values.", \
                rhino_value_kind_string(lhs.kind),                       \
                rhino_value_kind_string(rhs.kind));                      \
                                                                         \
        set_value(r, ins.x, 0, result);                                  \
        break;                                                           \
    }

#define CASE_COMPARE_ARITHMETIC(OP, operation)                           \
    case OP:                                                             \
    {                                                                    \
        RhinoValue lhs = get_value(r, ins.a, 0);                         \
        RhinoValue rhs = get_value(r, ins.b, 0);                         \
        bool result;                                                     \
                                                                         \
        if (lhs.kind == RHINO_INT && rhs.kind == RHINO_INT)              \
            result = lhs.as_int operation rhs.as_int;                    \
                                                                         \
        else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_INT)         \
            result = lhs.as_num operation rhs.as_int;                    \
                                                                         \
        else if (lhs.kind == RHINO_INT && rhs.kind == RHINO_NUM)         \
            result = lhs.as_int operation rhs.as_num;                    \
                                                                         \
        else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_NUM)         \
            result = lhs.as_num operation rhs.as_num;                    \
                                                                         \
        else                                                             \
            fatal_error(                                                 \
                "Could not interpret " #OP " between %s and %s values.", \
                rhino_value_kind_string(lhs.kind),                       \
                rhino_value_kind_string(rhs.kind));                      \
                                                                         \
        set_value(r, ins.x, 0, BOOL_VALUE(result));                      \
        break;                                                           \
    }

#define CASE_BINARY_LOGIC(OP, operation)                                 \
    case OP:                                                             \
    {                                                                    \
        RhinoValue lhs = get_value(r, ins.a, 0);                         \
        RhinoValue rhs = get_value(r, ins.b, 0);                         \
                                                                         \
        if (lhs.kind != RHINO_BOOL || rhs.kind != RHINO_BOOL)            \
            fatal_error(                                                 \
                "Could not interpret " #OP " between %s and %s values.", \
                rhino_value_kind_string(lhs.kind),                       \
                rhino_value_kind_string(rhs.kind));                      \
                                                                         \
        bool result = lhs.as_bool operation rhs.as_bool;                 \
        set_value(r, ins.x, 0, BOOL_VALUE(result));                      \
        break;                                                           \
    }

            CASE_BINARY_ARITHMETIC(OP_ADD, +)
            CASE_BINARY_ARITHMETIC(OP_SUB, -)
            CASE_BINARY_ARITHMETIC(OP_MUL, *)

        case OP_DIV:
        {
            RhinoValue lhs = get_value(r, ins.a, 0);
            RhinoValue rhs = get_value(r, ins.b, 0);
            RhinoValue result = {.kind = RHINO_NUM};

            if (lhs.kind == RHINO_INT && rhs.kind == RHINO_INT)
                result.as_num = (double)lhs.as_int / (double)rhs.as_int;

            else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_INT)
                result.as_num = lhs.as_num / (double)rhs.as_int;

            else if (lhs.kind == RHINO_INT && rhs.kind == RHINO_NUM)
                result.as_num = (double)lhs.as_int / rhs.as_num;

            else if (lhs.kind == RHINO_NUM && rhs.kind == RHINO_NUM)
                result.as_num = lhs.as_num / rhs.as_num;

            else
                fatal_error(
                    "Could not interpret OP_DIVIDE between %s and %s values.",
                    rhino_value_kind_string(lhs.kind),
                    rhino_value_kind_string(rhs.kind));

            set_value(r, ins.x, 0, result);
            break;
        }

        // FIXME: This does not implement Rhino semantics
        case OP_REM:
        {
            RhinoValue lhs = get_value(r, ins.a, 0);
            RhinoValue rhs = get_value(r, ins.b, 0);

            if (lhs.kind != RHINO_INT || rhs.kind != RHINO_INT)
                fatal_error(
                    "Could not interpret OP_REMAINDER between %s and %s values.",
                    rhino_value_kind_string(lhs.kind),
                    rhino_value_kind_string(rhs.kind));

            int result = lhs.as_int % rhs.as_int;
            set_value(r, ins.x, 0, INT_VALUE(result));
            break;
        }

        case OP_EQLA:
        case OP_EQLN:
        {
            RhinoValue lhs = get_value(r, ins.a, 0);
            RhinoValue rhs = get_value(r, ins.b, 0);
            bool result = false;

            // FIXME: Check this works for all data types
            // FIXME: Implement the correct semantics for strings
            if (lhs.kind == rhs.kind)
            {
                result = lhs.as_ptr == rhs.as_ptr;
            }

            if (ins.op == OP_EQLN)
                result = !result;

            set_value(r, ins.x, 0, BOOL_VALUE(result));
            break;
        }

            CASE_COMPARE_ARITHMETIC(OP_LESS_THN, <)
            CASE_COMPARE_ARITHMETIC(OP_LESS_EQL, <=)

            CASE_BINARY_LOGIC(OP_AND, &&)
            CASE_BINARY_LOGIC(OP_OR, ||)

#undef CASE_BINARY_ARITHMETIC
#undef CASE_COMPARE_ARITHMETIC
#undef CASE_BINARY_LOGIC

        default:
            fatal_error("Could not interpret %s instruction %p:%04X.", op_code_string((OpCode)ins.op), unit, program_counter - 1);
            break;
        }
    }
}

void interpret(ByteCode *byte_code, RunOnString *output_string)
{
    interpret_unit(byte_code->init, output_string);
}