// FIXME: The testing program currently cannot handle this

Token[] parser_tokens;
int parser_pos;
str? parser_error;

struct Token {
    enum Kind { NUM , ADD , SUB , MUL , DIV , OPEN , CLOSE , END }
    Kind kind;
    num value;
}

fn flag_error(str error) {
    if not parser_error:
        parser_error = error;
}

fn parse(str expr) -> num? {
    parser_tokens = [];
    parser_pos = 0;
    parser_error = null;

    tokenise(parser, expr);
    if parser_error: return;
    parse_expr(parser);
}

fn tokenise(str expr) {
    int i = 0;
    while i < #expr {
        Token t = { value: 0 };
        match expr[i] {
            "+": t.kind = ADD;
            "-": t.kind = SUB;
            "*": t.kind = MUL;
            "/": t.kind = DIV;
            "(": t.kind = OPEN;
            ")": t.kind = CLOSE;
            [0-9] {
                int j = i + 1;
                while expr[j] == [0-9]: j++;
                j--;
                t.value = str_to_int(expr[i:j]);
            }
            [%s]: continue;
            else: {
                flag_error(parser, "Unexpected '" + expr[i] + "'");
                return;
            }
        }
        insert(parser_tokens, t);
    }
    insert(parser_tokens, { kind: END , value: 0 });
}

// Grammar:
// expr   -> term   (( + - ) term  )*
// term   -> factor (( * / ) factor)*
// factor -> NUM
          -> "(" expr ")"

fn parse_expr(Parser parser) {
    def result = parse_term(parser)
    loop {
        match parser_tokens[parser_pos].kind:
            ADD: result += parse_term(parser);
            SUB: result -= parse_term(parser);
            else: break;
        parser_pos++;
    }
    return result;
}

fn parse_term(Parser parser) {
    def result = parse_factor(parser)
    loop {
        match parser_tokens[parser_pos].kind {
            MUL: result *= parse_factor(parser);
            DIV: result /= parse_factor(parser);
            else: break;
        }
        parser_pos++;
    }
    return result;
}

fn parse_factor(Parser parser) {
    Token token = parser_tokens[parser_pos];
    match token.kind {
        NUM {
            parser_pos++;
            return token.value;
        }
        OPEN {
            parser_pos++;
            local result = parse_expr(parser)
            if parser_tokens[parser_pos].kind != CLOSE:
                flag_error(parser, "Missing ')'");
            return result;
        }
        else {
            flag_error("Unexpected " + token.kind);
            return 0;
        }
    }
}

fn main() {
    Parser parser;

    loop {
        def expression = input();
        def result = parse(parser, expression);
        if parser_error:
            print(parser_error)
        else:
            print(result)
    }
}
